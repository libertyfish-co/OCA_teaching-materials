## 4.1 テスト駆動開発

ここではテスト駆動開発（Test Driven Development: TDD）について学びます。テスト駆動開発はアジャイル開発のプラクティスのひとつで、特にエクストリーム・プログラミング（XP）で重視されています。

### 4.1.1 概要

テスト駆動開発は「動作するきれいなコード」を作ることを目的とする開発手法です。

「動作する」と「きれいな」は次のような意味です。

- 動作する: プログラムが意図したような動きをすること
- きれいなコード: プログラムが読みやすく、機能拡張しやすいこと

テストコードは単なる動作確認の道具ではなく、開発を進めるためのガイドとして使います。

開発のステップは次のようになります。

1. プログラムにどのような機能を追加するか決める
2. （レッド）その機能のテストコードを書く
3. （グリーン）テストコードが成功するようにプログラムを変更する
4. （リファクタリング）テストコードを追加する状態を維持しながらプログラムを改善する
5. 1に戻る

これまでの授業ではプログラムを書いたあとでテストコードを作っていましたが、テスト駆動開発で最初に書くのはテストコードです。これを「テストファースト」といいます。

ステップ2ではテストを書いただけでプログラム本体には変更を加えていないので、テストは失敗するはずです。この状態を「レッド」と呼びます。

ステップ3でテストコードが成功した状態を「グリーン」といいます。ステップ3はテストコードを通せばよく、本当の意味で正しいプログラムを書く必要はありません。

最後のステップ4で、プログラムを修正していきます。この作業をリファクタリングと呼びます。

本当にこのステップが「動作するきれいなコード」が作るのに役立つのでしょうか？　もし役立つとしたら、それはなぜでしょうか？　実例をもとに見ていきましょう。

### 4.1.3 実例

与えられた年がうるう年か判定するプログラムを書いてみることにします。

判定ルールは以下の通りです。

- 通常の年は平年（うるう年ではない年）とする
- 4で割り切れる年はうるう年とする
- ただし、100で割り切れる年は平年とする
- ただし、400で割り切れる年はうるう年とする

手順1の「プログラムにどのような機能を追加するか決める」から進めていきます。

#### 最初のテスト

上のルールのどこから手をつけていけばいいでしょうか？　素直に最初のルールから作っていきたいところですが、「通常の年」というのはあまりはっきりしない概念です。わかりやすい「4で割り切れる年はうるう年とする」というルールから手をつけていきましょう。

まずはRSpecでテストを書きます。うるう年は英語でleap yearといいますから、`leap_spec.rb`というファイル名にします。

```rb
# leap_spec.rb

RSpec.describe
```

ここまで書いたところで手が止まりました。テストコードを書き進めるには、うるう年の判定処理の呼び出し方を決める必要があります。

簡単に`leap_year?`のようなメソッドをトップレベルに定義してもよさそうですが、ここでは`Date`という標準クラスに特異メソッド`leap?`を定義してみることにします。このメソッドは、引数として受け取った数値がうるう年であれば`true`を返すことにします。

`Date.leap?`のテストコードの枠組みは次のようになります。

```rb
require 'date'

RSpec.describe Date do
  describe '.leap?' do
  end
end
```

`Date.leap?`に4で割り切れる数値を渡すと`true`が返されるというテストを書いてみましょう。次のようになります。

```rb
require 'date'

RSpec.describe Date do
  describe '.leap?' do
    context '4で割り切れる年' do
      it 'うるう年になる' do
        expect(Date.leap?(4)).to be true
      end
    end
  end
end
```

このように、最初にテストコードを書こうとすると、「どのように作るか」の前に「何を作るか」を考えることになります。いきなりプログラムを書き始めると「どのように作るか」と「何を作るか」を同時に考えなければいけません。「どのように作るか」が難しいときには、「何を作るか」がぶれてしまったり、クラスやメソッドの設計に歪みが生まれることもあります。

#### テストのテスト

では、`rspec leap_spec.rb`でテストコードを実行してみましょう。`Date.leap?`メソッドはまだ作っていませんから、`NoMethodError`が出力されるはずです。

```
$ rspec leap_spec.rb
.

Finished in 0.00278 seconds (files took 0.11796 seconds to load)
1 example, 0 failures
```

予想に反して成功してしまいました。調べてみると、`Date.leap?`はRuby本体ですでに定義されていることがわかりました。

このように、失敗すると思っていたテストが成功してしまったり、予想とは違う理由で失敗したりすることがあります。プログラムを書いてしまってからそのような状況にぶつかると、テストに問題があるのか、プログラムに問題があるのか分からなくなってしまいます。もっと悪い場合には、テストが間違っているのにそれに気づかずに開発を進めてしまうこともあります。テストを書いたら、そのテストが期待通りに失敗することを忘れずに確認しましょう。

テストコードのおかげで`Date.leap?`というメソッドを知ることができましたが、このテキストでは`leap?`メソッドを引き続き作っていくことにします。

以下のようなコードを書いて、`leap_spec.rb`から読み込みます。今度はテストが失敗するはずです。

```rb
# leap.rb

require 'date'

class Date
  def self.leap?(year)
  end
end
```

```rb
# leap_spec.rb

require_relative './leap'

RSpec.describe Date do
  describe '.leap?' do
    context '4で割り切れる年' do
      it 'うるう年になる' do
        expect(Date.leap?(4)).to be true
      end
    end
  end
end
```

```
$ rspec leap_spec.rb
F

Failures:

  1) Date.leap? 4で割り切れる年 うるう年になる
     Failure/Error: expect(Date.leap?(4)).to be true

       expected true
            got nil
     # ./leap_spec.rb:9:in `block (4 levels) in <top (required)>'

Finished in 0.02341 seconds (files took 0.11577 seconds to load)
1 example, 1 failure

Failed examples:

rspec ./leap_spec.rb:8 # Date.leap? 4で割り切れる年 うるう年になる
```

うまく失敗しました。今は「レッド」の状態です。これで「その機能のテストコードを書く」というステップは完了です。

#### 最小のステップ

次のステップは「テストコードが通過するようにプログラムを書き換える」です。次のようにしてみましょう。

```rb
# leap.rb

require 'date'

class Date
  def self.leap?(year)
    true
  end
end
```

テストが成功したので、「グリーン」の状態にすることができました。予想通りの返り値を返すときちんとテストが成功することが確かめられたので、ステップは完了です。

しかし、これは明らかに間違ったプログラムです。`year`をまったく使っていません。次の「テストコードを追加する状態を維持しながらプログラムを改善する」のリファクタリングで修正していきましょう。

#### 間違いを直す

「4で割り切れる」が条件なので、`year`を4で割った余りを確認することにします。

```rb
# leap.rb

require 'date'

class Date
	def self.leap?(year)
		year % 4 == 0
  end
end
```

テストは成功です。

これで「4で割り切れる年はうるう年とする」というルールは満たせました。

- 通常の年は平年（うるう年ではない年）とする
- ~~4で割り切れる年はうるう年とする~~
- ただし、100で割り切れる年は平年とする
- ただし、400で割り切れる年はうるう年とする

先ほどの「グリーン」にするためだけの一時的な修正を「仮実装」と呼びます。今回の例ではプログラム本体もテストコードもごく簡単なものだったので、ただの遠回りのように見えますが、複雑な問題では便利な足がかりになります。崖にピッケルを打ち込んで足場を作るように、仮実装を使ってテストを成功させてから、徐々にプログラムを正しい形に近づけていくことができます。

#### 第2のテスト

では、「プログラムにどのような機能を追加するか決める」という最初のステップに戻りましょう。

ルールをあらためて読んでみると、100も400も4で割り切れるので、「通常の年」は「4で割り切れない年」と読み替えられることがわかります。「通常の年は平年（うるう年ではない年）とする」というルールを「4で割り切れない年は平年とする」に置き換えて、手をつけてみることにします。

次のステップは「その機能のテストコードを書く」でした。

```rb
# leap_spec.rb

require_relative './leap'

RSpec.describe Date do
  describe '.leap?' do
    context '4で割り切れる年' do
      it 'うるう年になる' do
        expect(Date.leap?(4)).to be true
      end
    end

    context '4で割り切れない年' do
      it '平年になる' do
        expect(Date.leap?(5)).to be false
      end
    end
  end
end
```

テストを実行してみると成功します。

```
$ rspec leap_spec.rb
..

Finished in 0.00339 seconds (files took 0.12956 seconds to load)
2 examples, 0 failures
```

「4で割り切れる」なら`true`、「4で割り切れない」なら`false`という処理になっているので、そのままで問題ないことがわかります。次の「テストコードが通過するようにプログラムを書き換える」というステップは不要でした。また「テストコードを追加する状態を維持しながらプログラムを改善する」も、まだ必要ないようなのでスキップします。

これで「4で割り切れない年は平年とする」も満たすことができました。

- ~~4で割り切れない年は平年とする~~
- ~~4で割り切れる年はうるう年とする~~
- ただし、100で割り切れる年は平年とする
- ただし、400で割り切れる年はうるう年とする

このように、プログラムを書いていく過程でやるべきことが変化したり、より簡単な条件に置き換えられることがあります。また、テスト駆動開発のステップは必要に応じてスキップすることができます。

#### 第3のテストと明白な実装

次は「ただし、100で割り切れる年は平年とする」というルールに手をつけることにします。

まずテストを書きましょう。

```rb
# leap_spec.rb

require_relative './leap'

RSpec.describe Date do
  describe '.leap?' do
    context '4で割り切れる年' do
      it 'うるう年になる' do
        expect(Date.leap?(4)).to be true
      end
    end

    context '4で割り切れない年' do
      it '平年になる' do
        expect(Date.leap?(5)).to be false
      end
    end

    context '100で割り切れる年' do
      it '平年になる' do
        expect(Date.leap?(100)).to be false
      end
    end
  end
end
```

4で割り切れるルールのため、うるう年と判定されるはずです。予想通りに失敗して、レッドになることを確かめます。

```
$ rspec leap_spec.rb
..F

Failures:

  1) Date.leap? 100で割り切れる年 平年になる
     Failure/Error: expect(Date.leap?(100)).to be false

       expected false
            got true
     # ./leap_spec.rb:21:in `block (4 levels) in <top (required)>'

Finished in 0.02186 seconds (files took 0.18779 seconds to load)
3 examples, 1 failure

Failed examples:

rspec ./leap_spec.rb:20 # Date.leap? 100で割り切れる年 平年になる
```

どのようにプログラムを直せばいいのかは明らかです。修正してみましょう。

```rb
# leap.rb

require 'date'

class Date
  def self.leap?(year)
    return false if year % 100 == 0

    year % 4 == 0
  end
end
```

無事にテストが通りました。グリーンです。

プログラムを修正する必要はないようなので、リファクタリングのステップは省略します。

このように「仮実装」を使わずに正しいプログラムに直接修正することを「明白な実装」と呼びます。

- ~~4で割り切れない年は平年とする~~
- ~~4で割り切れる年はうるう年とする~~
- ~~ただし、100で割り切れる年は平年とする~~
- ただし、400で割り切れる年はうるう年とする

#### 最後のテスト

最後に残った「ただし、400で割り切れる年はうるう年とする」に手をつけましょう。

まずテストを書いて、正しく失敗することを確かめ、レッドにします。

```rb
# leap_spec.rb

require_relative './leap'

RSpec.describe Date do
  describe '.leap?' do
    context '4で割り切れる年' do
      it 'うるう年になる' do
        expect(Date.leap?(4)).to be true
      end
    end

    context '4で割り切れない年' do
      it '平年になる' do
        expect(Date.leap?(5)).to be false
      end
    end

    context '100で割り切れる年' do
      it '平年になる' do
        expect(Date.leap?(100)).to be false
      end
    end

    context '400で割り切れる年' do
      it 'うるう年になる' do
        expect(Date.leap?(400)).to be true
      end
    end
  end
end
```

そしてグリーンにします。

```rb
# leap.rb

require 'date'

class Date
  def self.leap?(year)
    return true if year % 400 == 0
    return false if year % 100 == 0

    year % 4 == 0
  end
end
```

最後にリファクタリングのステップに移りましょう。このプログラムに改善できるところはあるでしょうか？　すこし複雑な条件文ですが、テストコードがあるので、誤ってプログラムを壊してしまうことを心配せずに変更を試すことができます。

十分に改善できたと感じたら、うるう年を判定する「動作するきれいなコード」の完成です。

- ~~4で割り切れない年は平年とする~~
- ~~4で割り切れる年はうるう年とする~~
- ~~ただし、100で割り切れる年は平年とする~~
- ~~ただし、400で割り切れる年はうるう年とする~~

### ふりかえり

テスト駆動開発のステップを繰り返しながらプログラムを実際に作成してみました。実際のテスト駆動開発でも、課題の難しさに応じて「仮実装」と「明白な実装」で歩幅の大きさを調節しながら一歩ずつ進んでいくことになります。

テスト駆動開発を実際のプログラムに適用するためには練習が必要となります。また、テストから実装方針を検討するための「三角測量」などのテクニックや、大きなプログラムを「グリーン」に保ちながら少しずつ書き換えていく手法についてはここでは扱いませんでした。関心のある人は章末の参考文献の『テスト駆動開発』を参照してください。

### テスト駆動開発の意義

テスト駆動開発では、「動作するきれいなコード」という目標を「動作するコード」と「きれいなコード」に分割します。そして、テストコードで後戻りを防ぎながら一歩ずつ完成に近づいていきます。

アジャイル開発は顧客から小刻みにフィードバックを受け取ってプロジェクトを適切な方向に進めていく開発手法でした。テスト駆動開発は、テストコードから小刻みにフィードバックを受け取って、プログラムを適切な方向に育てていく開発手法と考えることができます。

テストコードの成功・失敗がフィードバックにあたります。また、紙幅の都合から具体例を上げることはできませんでしたが、テストコードから先に作ることそのものがプログラムの設計に対するフィードバックとなり、よりよい設計を考えるきっかけになります。

とはいえ、細かくフィードバックを受けなくても前に進んでいける局面もあります。テスト駆動開発を学んだからといって、常にテスト駆動開発を使わないといけないわけではありません。「動作するきれいなコード」にひと息でたどりつけるときには、あえて回り道をする必要はないでしょう。もし道を見失ったときには、テスト駆動開発のテクニックを思い出してみてください。

### テスト駆動開発の限界

テスト駆動開発がうまく適用できない場面もあります。以下のようなポイントについては、自動テストから適切なフィードバックを得るのは難しいでしょう。

- 使い勝手のよいユーザーインターフェースになっているか: 自動テストを使えば、仕様通りのインターフェースが作れているかを確認することはできます。しかし、インターフェースが使いやすいかどうか、また、インターフェースをどのように改善するべきかといったフィードバックを得ることは難しいでしょう。
- 並行処理が正しく実装できているか: 自動テストで状況を再現するのが難しい分野がいくつかあります。処理の実行タイミングに左右される並行処理はその代表例です。

また、テスト駆動開発で作られたテストコードは製品の品質を保証するテストとしては必ずしも十分ではありません。テストケースを通過することは確かめられますが、テストケースそのものが十分かどうかはわからないのです。（たとえば、今回作った`Date.leap?`メソッドに小数を渡したら、どのような結果を返すべきでしょうか？）

### まとめ

ここではテスト駆動開発の目的と進め方、意義と限界について学びました。ポイントをおさらいしておきましょう。

- テスト駆動開発は「動作するきれいなコード」を作ることを目的とする
- テスト駆動開発はテストコードからフィードバックを得て、小刻みに開発を進める
- テスト駆動開発がうまく適用できない場面もある

### 発展課題

- これまでに書いたプログラムをテスト駆動開発で作り直してみましょう。どれだけ細かいステップに分解できるでしょうか？
- 最寄りの映画館のチケット料金の計算ルールを調べて、チケット料金を計算するプログラムをテスト駆動開発で作ってみましょう。

### 参考資料

- 和田卓人「50分でわかるテスト駆動開発」https://www.slideshare.net/decode2017/do03-50
  - テスト駆動開発の実演を含む講演の動画です。テスト駆動開発の意義と進め方がコンパクトに解説されています。
- Kent Beck『テスト駆動開発』、和田卓人訳、オーム社、2017年
  - テスト駆動開発の提唱者による書籍の新訳版です。テスト駆動開発の意義が詳細に説明されています。また、複雑なプログラムをテスト駆動開発で作る実例が盛り込まれています。
- Martin Fowlerほか「Is TDD dead?」https://martinfowler.com/articles/is-tdd-dead/
  - 2014年にRuby on Railsの作者が提起した「テスト駆動開発は有効な開発手法ではない」という主張をめぐる議論をまとめたページです。テスト駆動開発を実践する際の課題とその解決策が語られています。
