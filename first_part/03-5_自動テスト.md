## 3.5 Ruby: 自動テスト

ここでは、意図通りに動作するプログラムを素早く正確に作るために、プログラムのテストを自動化する方法を学びます。

プログラムのコンポーネント単位（特定のメソッドなど）をテストの対象にする「単体テスト」（ユニットテスト）を扱います。

### 3.5.1 なぜテストを自動化するのか

すこし前の授業で、与えられた数値について以下の動作を行うプログラムを作りました。

- 3で割り切れる場合には、"Fizz"を出力する
- 5で割り切れる場合には、"Buzz"を出力する
- 3と5の両方で割り切れる場合には、"FizzBuzz"を出力する
- どれでもない場合には与えられた数値を出力する

このFizzBuzzプログラムを作るとき、どのように作業を進めたでしょうか？　おそらく、以下のようなステップを繰り返したと思います。

1. プログラムを書く
2. 動作を確認する
3. 不具合があればプログラムを直す
4. もう一度動作を確認する

FizzBuzzプログラムはとても単純ですが、それでも出力が正しいことを目視で確認するのは面倒だったのではないでしょうか。

このような手動のテストに時間を使うのは非効率ですし、気をつけていても確認漏れが起こることもあります。なにより、人間が繰り返すにはあまりにも退屈な作業です。

決められた作業を正確に行うのは人間よりもプログラムのほうが得意です。そこで、プログラムをテストするためのプログラムを作って、テストを自動化するというプラクティスが広く行われています。

### 3.5.2 テストケースを考える

それではFizzBuzzプログラムのロジックを確認するためのテストケースを用意しましょう。「どんな入力を与えたとき、どんな出力を期待するか」をテストケースと呼びます。

もっとも簡単なテストケースは以下のようになります。

| 入力 | 期待する出力 |
|---|---|
| 1 | 1 |
| 3 | Fizz |
| 5 | Buzz |
| 15 | FizzBuzz |

### 3.5.3 テストしやすい設計

外部から見ると同じ動作をするプログラムでも、自動テストを書きやすいものと書きにくいものがあります。

まず、次のコードを読んでみてください。

```rb
# main.rb
1.upto(100) do |n|
  words = ''
  words << 'Fizz' if n % 3 == 0
  words << 'Buzz' if n % 5 == 0
  puts words.empty? ? n : words
end
```

10行足らずのごく短いコードですが、自動テストを書くのは簡単ではありません。

繰り返し処理の中にすべての処理が直接書かれていて、動作をテストするにも1から100までの全出力を扱わなければいけないからです。

一方、次のコードでは、数字を受け取って出力内容を返す処理が`fizzbuzz`メソッドとして切り出されています。

```rb
# fizzbuzz.rb
def fizzbuzz(n)
  words = ''
  words << 'Fizz' if n % 3 == 0
  words << 'Buzz' if n % 5 == 0
  words.empty? ? n : words
end
```

```rb
# main.rb
require_relative './fizzbuzz'

1.upto(100) do |n|
  puts fizzbuzz(n)
end
```

このように処理をメソッドとして切り出すことで、テストケースの入力と出力をメソッドの引数と返り値と対応づけることができます。

### 3.5.4 テストを書いてみる

それではテストを書いてみましょう。

```rb
require_relative './fizzbuzz'

def check(input, expected)
  actual = fizzbuzz(input)
  unless actual == expected
    abort "テストに失敗しました。\n入力値: #{input}, 期待する出力: #{expected}, 実際の出力: #{actual}"
  end
end

check(1, 1)
check(3, 'Fizz')
check(5, 'Buzz')
check(15, 'FizzBuzz')

puts 'テストに成功しました'
```

`fizzbuzz`メソッドから返ってきた実際の出力と期待する出力を比較して、違いがあれば報告されるようになっています。

### 3.5.5 仕様書としてのテストコード

以下のようにコメントをつけることで、テストコード上でプログラムの仕様を説明することができます。

```rb
# 普通の数字を入力するとそのまま返される
check(1, 1)

# 3の倍数を入力するとFizzが返される
check(3, 'Fizz')

# 5の倍数を入力するとBuzzが返される
check(5, 'Buzz')

# 15の倍数を入力するとFizzBuzzが返される
check(15, 'FizzBuzz')
```

このようにテストコードとペアになった仕様書には次のようなメリットがあります。

- テストコードとして実行できるため、正しさを検証しやすい
- テストコードは開発にも使用するため、更新忘れが起きにくい

### 3.5.6 すべてをテストすることはできない

ところで、今回使ったテストケースを通過したとしても、コードが正しく動作すると保証することはできません。

| 入力 | 期待する出力 |
|---|---|
| 1 | 1 |
| 3 | Fizz |
| 5 | Buzz |
| 15 | FizzBuzz |

たとえば、仕様を誤解して以下のようなプログラムを作ってしまったらどうなるでしょうか？

```rb
def fizzbuzz(n)
  case n
  when 0...3
    n
  when 3...5
    'Fizz'
  when 5...15
    'Buzz'
  when 15...Float::INFINITY
    'FizzBuzz'
  else
    n
  end
end
```

<!--
# 動作確認用コード
[1, 3, 5, 15].each do |n|
  p fizzbuzz(n)
end
-->

このようにプログラムに誤りがあっても、たまたま期待通りの出力になってしまい、コードの誤りを見つけられないこともあります。

今回の`fizzbuzz`メソッドはすべての数値を引数として受け付けるため、有限のテストケースでは動作を完全に検証することはできません。むやみにテストケースを増やすとテストの実行時間が長くなり、メンテナンスの手間もかさみますから、効率のよいテストケースを考える必要があります。

ここでは詳細を説明することはできませんが、少ないテストケースでできるだけ効率よくプログラムの動作を検証するための技法は古くから研究されており、それを主題にした書籍も多数出版されています。また、コードが仕様通りに動作することを数学的に証明する形式手法などのアプローチも実用化されています。関心があれば「テスト設計」「形式手法」などをキーワードにして探してみてください。

### 3.5.7 自動テストとアジャイル開発

今回学んだ自動テストは、アジャイル開発のいくつかのプラクティスと深い関わりを持ちます。

#### a) テスト駆動開発

テスト駆動開発は、自動テストを開発の起点にすることで変更コストの低いコードを作ることを目指します。

#### b) 継続的インテグレーション・継続的デプロイ

成果物を素早くメインライン（trunkブランチ、masterブランチなどと呼ばれます）にマージして、自動的に出荷可能な状態にするプラクティスです。

成果物がマージ可能であること、出荷可能であることを保証するための手段として自動テストが利用されます。

### 3.5.8 まとめ

ここではプログラムの自動テストについて学びました。ポイントをおさらいしておきましょう。

- プログラムをテストするプログラムを作ることで、テストを自動化できる
- 自動化されたテストは、意図通りに動作するプログラムを素早く正確に作ることに役立つ
- 同じ動作をするプログラムでも、内部設計によって自動テストの作りやすさに違いがある
    - ロジックをメソッドとして切り出すことで自動テストを作りやすいプログラムにすることができる
- 自動テストだけでプログラムの正しさを保証することができるとは限らない
- 自動テストはアジャイルのプラクティスと深い関わりを持っている

### 3.5.9 発展課題

- FizzBuzzプログラムに「数字が7で割り切れる場合には、数字の代わりに"Jazz"を出力する」というルールを追加したとき、テストケースはどのように変化するか考えてみましょう。
- じゃんけんプログラムを作り、それに対する自動テストを作ってみましょう。仕様は以下の通りです。
    1. プレイヤーからG, C, Pのどれかの入力を受け取り、プレイヤーの手とする
      - 入力と手の対応はG: グー, C: チョキ, P: パーとする
    2. プログラムはランダムに自分の手を選び、画面に表示する
    3. プレイヤーとプログラムの手を比較し、どちらが勝ったかを画面に表示する
- この授業で作った自動テストの仕組みに不便なところはありますか？　もし不便なところがあれば、その理由を考えて改善してみましょう。
